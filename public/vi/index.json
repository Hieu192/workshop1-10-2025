[{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/5-stepoptimal/5.1-createsqsdead/","title":"Cấu hình hàng đợi thư chết","tags":[],"description":"","content":"Vì sao chúng ta cần tạo Dead-Letter Queue (DLQ)? Chúng ta cần Dead-Letter Queue (DLQ) để lưu lại các message bị xử lý lỗi nhiều lần, giúp: Phân tích nguyên nhân lỗi mà không mất dữ liệu. Tránh vòng lặp xử lý vô hạn trong Lambda hoặc SQS. Đảm bảo độ tin cậy và khả năng khôi phục của hệ thống. Mục tiêu Tạo một hàng đợi \u0026ldquo;rác\u0026rdquo; (DLQ). Cấu hình OrderingQueue1 chính của chúng ta để nếu một tin nhắn (đơn hàng) bị xử lý lỗi 3 lần, nó sẽ tự động bị \u0026ldquo;vứt\u0026rdquo; sang hàng đợi DLQ này. Điều này giúp các đơn hàng tốt khác vẫn được xử lý bình thường. Thực hành Truy cập vào dịch vụ SQS:\nClick Create queue Name nhập: OrderingQueue1_DLQ Để mặc đinh hết, kéo xuống tận cùng và click Create queue Ở giao diện danh sách hàng đợi SQS, click vào OrderingQueue1 và click Edit ở góc phải\nCuộn xuống tìm phần Dead-letter queue và click Enable Chọn DLQ mà bạn vừa tạo ở bước 1 Maximum receives nhập 3 Maximum receives có nghĩa là Lambda được phép thử xử lý một tin nhắn. Nếu nó báo lỗi (fail), SQS sẽ giữ lại và giao lại sau. Nếu quá trình này \u0026ldquo;thất bại\u0026rdquo; tổng cộng 3 lần, SQS sẽ từ bỏ và chuyển tin nhắn đó sang DLQ.\nTest thử với DLQ\nChúng ta cần phải sửa một chút code lambda function để mô phỏng lỗi để test DLQ Truy cập vào dịch vụ Lambda, click OrderingFunction1, mở tab Code và thêm dòng này như ảnh dưới và click Deploy console.log(\u0026#34;!!! ĐANG TEST DLQ - CỐ TÌNH GÂY LỖI !!!\u0026#34;); throw new Error(\u0026#34;Đây là lỗi giả lập để test DLQ\u0026#34;); Mở Postman, gọi /basket/checkout 4 lần để test Truy cập lại SQS, và thấy tin nhắn của OrderingQueue có 3 tin nhắn đang chuyển đi, và OrderingQueue1_DLQ đang giữ 1 tin nhắn thành công. Đợi một lúc, tất cả tin nhắn lỗi đã được chuyển thành công an toàn vào DLQ. Xóa code mô phỏng lỗi trên lambda\n"},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/1-introduce/","title":"Giới thiệu","tags":[],"description":"","content":"Giới thiệu kiến trúc Microservice trên AWS Hệ thống được thiết kế theo mô hình Serverless Microservices Architecture trên AWS Cloud, gồm ba microservice chính:\nProduct Microservice – quản lý danh sách và thông tin sản phẩm Basket Microservice – quản lý giỏ hàng của người dùng Order Microservice – xử lý đơn hàng và giao dịch thanh toán Mỗi microservice hoạt động độc lập, được triển khai hoàn toàn bằng các dịch vụ serverless như API Gateway, AWS Lambda, và Amazon DynamoDB.\nLuồng hoạt động của hệ thống:\nNgười dùng (User) truy cập ứng dụng và đăng nhập thông qua Amazon Cognito, dịch vụ xác thực và quản lý người dùng của AWS. Sau khi xác thực, người dùng gửi các yêu cầu (API request) đến AWS API Gateway. API Gateway định tuyến yêu cầu đến đúng microservice tương ứng. Product Microservice nhận yêu cầu lấy dữ liệu sản phẩm, Lambda xử lý logic và truy xuất dữ liệu trong DynamoDB Table. Basket Microservice quản lý các thao tác giỏ hàng (thêm, xoá, cập nhật sản phẩm). Khi người dùng nhấn Checkout, dịch vụ này sẽ phát một Checkout Event lên AWS EventBridge Event Bus. AWS EventBridge nhận sự kiện và dựa vào EventBridge Rule để định tuyến sự kiện sang AWS SQS Queue. Order Microservice lắng nghe hàng đợi SQS, lấy sự kiện mới và thực thi Lambda để tạo đơn hàng trong DynamoDB Table. Toàn bộ quá trình được giám sát bởi Amazon CloudWatch, và quyền truy cập của các thành phần được quản lý thông qua AWS IAM. Lợi ích của kiến trúc:\nTách biệt dịch vụ: Mỗi microservice có logic và cơ sở dữ liệu riêng, giúp dễ mở rộng và bảo trì. Tự động mở rộng (Auto Scaling): Lambda có khả năng tự động mở rộng theo số lượng yêu cầu mà không cần quản lý hạ tầng. Tích hợp sự kiện (Event-driven): EventBridge và SQS giúp các microservice giao tiếp bất đồng bộ, giảm độ trễ và tăng tính linh hoạt. Giám sát và bảo mật mạnh mẽ: CloudWatch và IAM giúp đảm bảo an toàn và theo dõi hiệu năng toàn hệ thống. Không máy chủ (Serverless): Toàn bộ hệ thống không cần quản lý server, tiết kiệm chi phí và tối ưu vận hành. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/2-preparationsteps/2.1-createtabledynamo/","title":"Tạo DynamoDB Tables","tags":[],"description":"","content":"Trong bước này, chúng ta sẽ tạo các bảng DynamoDB cần thiết cho ứng dụng microservice.\nTạo ProductTable Truy cập AWS Console và điều hướng đến dịch vụ DynamoDB. Từ giao diện DynamoDB, click Create table. Tạo bảng ProductTable Table name nhập: ProductTable Partition key nhập: productId (String) Giữ các cài đặt khác mặc định và click Create table. Tạo BasketTable Tương tự như trên, cấu hình bảng: Table name nhập: BasketTable Partition key: userId (String) Giữ các cài đặt khác mặc định và click Create table. Tạo OrderingTable Click Create table lần nữa.\nCấu hình bảng:\nTable name: OrderingTable Partition key: orderId (String) Giữ các cài đặt khác mặc định và click Create table.\nĐợi tất cả các bảng được tạo thành công và có dạng như hình dưới với Status là Active. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/3-processorderhandler/3.1-createsqs/","title":"Tạo hàng đợi SQS","tags":[],"description":"","content":"SQS là gì SQS là viết tắt của Amazon Simple Queue Service – một dịch vụ hàng đợi tin nhắn (message queue) được quản lý hoàn toàn bởi AWS. Nó là dịch vụ cho phép bạn gửi, lưu trữ và nhận tin nhắn giữa các thành phần phần mềm một cách bất đồng bộ (asynchronous), mà không cần các thành phần phải chạy cùng lúc hoặc biết vị trí của nhau.\nTạo SQS Truy cập AWS Console, nhập SQS và truy cập vào dịch vụ Simple Queue Service Ở giao diện Amazon SQS, chọn Create queue Ở giao diện tạo queue:\nType chọn Standard Name nhập: OrderingQueue1 Kéo xuống và nhấn Create queue Hoàn thành tạo SQS. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/4-apigateway/4.1-createrestapi/","title":"Tạo Rest API","tags":[],"description":"","content":"Rest API là gì REST API (Representational State Transfer API) là giao diện cho phép các hệ thống giao tiếp qua HTTP bằng cách trao đổi dữ liệu (thường ở dạng JSON).Giúp các microservice (như Order, Payment, Inventory\u0026hellip;) giao tiếp thống nhất, tách biệt logic xử lý, dễ mở rộng và tích hợp với các cơ chế bất đồng bộ như SQS hoặc EventBridge trong hệ thống order.\nMục tiêu Mục tiêu của phần thực hành là tạo và cấu hình REST API trên Amazon API Gateway, giúp các microservice (như Product, Basket, Order) có thể giao tiếp thông qua HTTP endpoint, phục vụ cho luồng xử lý bất đồng bộ trong Order Microservice.\nThực hành Truy cập AWS Console, nhập API Gateway và truy cập vào dịch vụ API Gateway Chọn APIs ở sidebar bên trái, sau đó click Create API Lướt xuống tìm REST API rồi click Build Trong giao diện Create REST API Chọn New API API name nhập: EcommerceAPI1 API endpoint type: Regional Click Create API Sau khi tạo xong click vào / và click tiếp vào Create resource Ở phần Resource name nhập products và click Create resource Click vào /products vừa tạo, click Create method Trong giao diện Method details Method type chọn GET Integration type chọn Lambda function Click Lambda proxy integration Lambda function chọn ProductFunction1 9. Hoàn thành tạo một api /products Tạo /basket 11. Tạo /basket/checkout 12. Tạo /orders Kết quả Deploy API\nClick Deploy API Stage chọn New stage\nStage name nhập: prod\nClick Deploy "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/6-cognito/6.1-createuserpool/","title":"Tạo User Pool","tags":[],"description":"","content":"Thực hành Trong AWS Console, nhập Cognito và click. Từ giao diện, click User Pool từ slider bên trái và click Create user pool Từ giao diện dưới nhập\nApplication type chọn Single-page application (SPA) Name your application nhập ECommerceAppClient Options for sign-in identifiers click Email Self-registration click Enable self-registration Return URL nhập http://localhost:3000 Click Create user directory "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/","title":"Triển khai fullstack app với kiến trúc ba tầng","tags":[],"description":"","content":"Xây dựng hệ thống xử lý đơn hàng trên nền tảng AWS Serverless Tổng quan Trong bài workshop này, chúng ta sẽ cùng nhau xây dựng một hệ thống xử lý đơn hàng đơn giản theo kiến trúc microservice trên nền tảng AWS Serverless.\nNội dung Giới thiệu Các bước chuẩn bị Luồng xử lý order API Gateway Các bước tối ưu Cognito Xóa tài nguyên "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/2-preparationsteps/","title":"Các bước chuẩn bị","tags":[],"description":"","content":"Trong phần này, chúng ta sẽ chuẩn bị các tài nguyên AWS cần thiết cho ứng dụng microservice serverless.\nNội dung Tạo DynamoDB Tables Tạo IAM Roles Tạo Lambda Functions "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/6-cognito/6.2-configureapigateway/","title":"Cấu hình Authorizer cho API Gateway","tags":[],"description":"","content":"Mục tiêu Tạo một \u0026ldquo;Authorizer\u0026rdquo; (Người gác cổng) trong API Gateway. Authorizer này sẽ sử dụng Cognito User Pool của bạn để kiểm tra. Bất kỳ ai \u0026ldquo;gõ cửa\u0026rdquo; (gọi API) mà không có \u0026ldquo;Token\u0026rdquo; (giấy thông hành) hợp lệ sẽ bị chặn lại.\nThực hành Truy cập vào API Gateway, từ giao diện click vào EcommerceAPI1\nTừ slider bên trái click vào Authorizers Click vào Create authorizers Từ giao diện Create authorizer\nAuthorizer name nhập: ECommerceAuthorizer Authorizer type chọn: Cognito Cognito user pool chọn user pool mình vừa tạo ở bước trước Token source nhập: Authorization Hoàn thành tạo authorizer, chúng ta gắn cho api quan trọng Tương tự với api /basket/checkout, /orders Vì chúng ta vừa gắn authorizer cho API nên chúng ta cần phải deploy lại và test api trên Postman. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/3-processorderhandler/3.2-createeventbridgerule/","title":"Chuẩn bị Trung tâm điều phối (Amazon EventBridge)","tags":[],"description":"","content":"EventBridge Rule là gì SQS là viết tắt của Amazon Simple Queue Service – một dịch vụ hàng đợi tin nhắn (message queue) được quản lý hoàn toàn bởi AWS. Nó là dịch vụ cho phép bạn gửi, lưu trữ và nhận tin nhắn giữa các thành phần phần mềm một cách bất đồng bộ (asynchronous), mà không cần các thành phần phải chạy cùng lúc hoặc biết vị trí của nhau.\nMục tiêu Nhập SQS và truy cập vào dịch vụ Simple Queue Service Ở giao diện Amazon SQS, chọn Create queue Ở giao diện tạo queue:\nType chọn Standard Name nhập: OrderingQueue1 Kéo xuống và nhấn Create queue Hoàn thành tạo SQS. Thực hành Truy cập AWS Console, nhập EventBridge và truy cập vào dịch vụ Amazon EventBridge Từ giao diện, chọn Rule ở slider bên trái và click Create rule Từ giao diện Create rule\nName nhập: CheckoutToOrderingRule1 Click Next Trong bước Build event pattern\nEvent source chọn Other Event pattern chọn Custom pattern (JSON editor) Click Next { \u0026#34;source\u0026#34;: [\u0026#34;com.ecommerce.basket\u0026#34;], \u0026#34;detail-type\u0026#34;: [\u0026#34;CheckoutEvent\u0026#34;] } Trong bước Select target\nTarget type chọn AWS service Select a target chọn SQS queue Queue chọn OrderingQueue1 Click Next Kiểm tra lại và click Create rule Tạo thành công EventBridge Rule bằng cách check Status là Enabled "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/5-stepoptimal/5.2-createindex/","title":"Tạo Global Secondary Index cho OrderingTable","tags":[],"description":"","content":"Tại sao cần tạo Global Secondary Index(GSI) ? Hiện tại, API GET /orders của chúng ta đang dùng lệnh Scan. Scan sẽ đọc toàn bộ bảng OrderingTable rồi lọc ra kết quả. Khi bạn chỉ có 10 đơn hàng, nó rất nhanh. Nhưng khi bạn có 10 triệu đơn hàng, nó sẽ cực kỳ chậm và rất tốn kém. Chính vì vậy chúng ta cần tạo một \u0026ldquo;bản sao\u0026rdquo; của bảng, nhưng được sắp xếp theo userId để có thể \u0026ldquo;nhảy\u0026rdquo; thẳng đến đơn hàng của một người dùng cụ thể mà không cần quét. Cái này gọi là Global Secondary Index (GSI). Tạo Global Secondary Index(GSI) Tại giao diện DynamoDB, chọn Table ở sidebar bên trái, sau đó chọn OrderingTable Tại giao diện OrderingTable\nMở tab Indexs và click. Tiếp theo click Create index Từ giao diện\nPartition key nhập: userId Index name: UserOrdersIndex Attribute projections chọn All Tiếp theo click Create index và chờ đến khi nó active Tại giao diện Lambda function OrderingFunction1, hãy sửa code để sử dụng index và click deploy\nimport { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, PutCommand, ScanCommand, QueryCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { randomUUID } from \u0026#34;crypto\u0026#34;; const ddbClient = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(ddbClient); const orderTable = \u0026#34;OrderingTable\u0026#34;; const indexName = \u0026#34;UserOrdersIndex\u0026#34;; // Tên GSI của chúng ta export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); // ----- XỬ LÝ KHI ĐƯỢC KÍCH HOẠT BỞI SQS ----- if (event.Records) { console.log(\u0026#34;Processing SQS message...\u0026#34;); try { for (const record of event.Records) { const sqsBody = JSON.parse(record.body); const checkoutEventData = sqsBody.detail; console.log(\u0026#34;Checkout data from SQS:\u0026#34;, checkoutEventData); const orderId = randomUUID(); const orderParams = { TableName: orderTable, Item: { orderId: orderId, userId: checkoutEventData.userId, items: checkoutEventData.items, status: \u0026#34;PENDING\u0026#34;, createdAt: new Date().toISOString() } }; await ddbDocClient.send(new PutCommand(orderParams)); console.log(`Order ${orderId} saved successfully.`); } return { message: \u0026#34;SQS messages processed successfully.\u0026#34; }; } catch (err) { console.error(\u0026#34;Error processing SQS message:\u0026#34;, err); throw err; } } // ----- XỬ LÝ KHI ĐƯỢC KÍCH HOẠT BỞI API GATEWAY ----- else if (event.httpMethod) { console.log(\u0026#34;Processing API Gateway request...\u0026#34;); if (event.httpMethod === \u0026#34;GET\u0026#34;) { let responseBody; try { // KIỂM TRA XEM CÓ TRUY VẤN BẰNG userId KHÔNG if (event.queryStringParameters \u0026amp;\u0026amp; event.queryStringParameters.userId) { const userId = event.queryStringParameters.userId; console.log(`Querying orders for userId: ${userId} using GSI`); const params = { TableName: orderTable, IndexName: indexName, KeyConditionExpression: \u0026#34;userId = :uid\u0026#34;, ExpressionAttributeValues: { \u0026#34;:uid\u0026#34;: userId } }; const { Items } = await ddbDocClient.send(new QueryCommand(params)); responseBody = Items; } else { console.log(\u0026#34;Scanning all orders (no userId provided)\u0026#34;); const params = { TableName: orderTable, }; const { Items } = await ddbDocClient.send(new ScanCommand(params)); responseBody = Items; } return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(responseBody) }; } catch (err) { console.error(err); return { statusCode: 500, body: JSON.stringify({ message: \u0026#34;Internal server error\u0026#34;, error: err.message }) }; } } } // Trường hợp không xác định console.warn(\u0026#34;Unknown event type\u0026#34;); return { statusCode: 400, body: JSON.stringify({ message: \u0026#34;Unsupported event source\u0026#34; }) }; }; Test API với Postman để kiểm tra tốc độ Test với /orders và xem tốc độ phản hồi Test với /orders?userId=user-test-02 và xem tốc độ phản hồi Từ hình ảnh trên a thấy index thì tốc độ phản hồi nhanh hơn, mặc dù không quá lớn đối với dữ liệu ít (vài chục order). Nhưng khi dữ liệu đến hàng triệu, hàng tỷ thì index này có tốc độ nhanh hơn gấp trăm lần thậm chí có thể hàng nghìn lần. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/2-preparationsteps/2.2-createiam/","title":"Tạo IAM Roles","tags":[],"description":"","content":"Chúng ta cần tạo các IAM role cho các Lambda function để truy cập DynamoDB và các dịch vụ AWS khác.\nBước 1: Tạo Custom Policies Tạo AllowReadProductTablePolicy1 Truy cập AWS Console và điều hướng đến dịch vụ IAM trong AWS Console. Click Policies ở sidebar bên trái, sau đó Create policy. Chọn tab JSON và paste policy sau: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:Scan\u0026#34;, ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:*:*:table/ProductTable\u0026#34; } ] } Click Next. Tiếp theo chúng ta nhập như bên dưới\nPolicy name nhập: AllowReadProductTablePolicy1 Nhấn Create policy Click Create policy.\nTạo AllowReadWriteBasketTablePolicy1 Tương tự như trên, tạo policy mới với JSON sau: Policy name nhập: AllowReadWriteBasketTablePolicy1 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:UpdateItem\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:*:*:table/BasketTable\u0026#34; }, ] } Tạo AllowWriteOrderingTablePolicy1 Tạo policy mới với JSON sau: Policy name nhập: AllowWriteOrderingTablePolicy1 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:Scan\u0026#34;, \u0026#34;dynamodb:Query\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:dynamodb:*:*:table/OrderingTable\u0026#34;, \u0026#34;arn:aws:dynamodb:*:*:table/OrderingTable/index/UserOrdersIndex\u0026#34; ] }, ] } Tạo AllowPutEventsToDefaultBusPolicy1 Tạo policy mới với JSON sau: Policy name nhập: AllowPutEventsToDefaultBusPolicy1 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;events:PutEvents\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:events:*:*:event-bus/default\u0026#34; } ] } Bước 2: Tạo IAM Roles Tạo ProductLambdaRole Click Roles ở sidebar bên trái, sau đó Create role. Chọn AWS service và chọn Lambda. Click Next. Tìm và chọn policy: AllowReadProductTablePolicy1, AWSLambdaBasicExecutionRole và chọn Next Role name nhập: ProductLambdaRole1 Click Create role.\nTạo BasketLambdaRole Lặp lại các bước tương tự với: Role name: BasketLambdaRole1 Gắn policy: AllowPutEventsToDefaultBusPolicy1, AllowReadWriteBasketTablePolicy1, AWSLambdaBasicExecutionRole Tạo OrderingLambdaRole Lặp lại các bước tương tự với: Role name: OrderingLambdaRole1 Gắn policy: AllowWriteOrderingTablePolicy1, AWSLambdaBasicExecutionRole, AWSLambdaSQSQueueExecutionRole Xác nhận Sau khi hoàn thành, bạn sẽ có:\n4 custom policies với quyền tối thiểu cần thiết 3 IAM roles tương ứng cho từng Lambda function "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/4-apigateway/4.2-testapi/","title":"Test API trên Postman","tags":[],"description":"","content":"Postman là gì Postman là công cụ hỗ trợ gửi và kiểm thử API một cách trực quan, giúp nhà phát triển gửi yêu cầu (request) đến các endpoint (như API Gateway) và xem phản hồi (response) từ server, phục vụ cho việc kiểm thử và gỡ lỗi API trong quá trình phát triển hệ thống microservice.\nThực hành test api Tạo dữ liệu productTable trên dynamoDB để test Click Create item Click Json view Click View DynamoDB Json { \u0026#34;productId\u0026#34;: \u0026#34;p-001\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Kim Đồng\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Conan tập 1\u0026#34;, \u0026#34;price\u0026#34;: 250000 } - Tương tự tạo 5-10 mẫu (Hoặc bạn cũng có thể gọi API để làm nhanh) Lấy URL của API Gateway để test trên Postman Mở Postman và test /products Tiếp tục test /basket\n{ \u0026#34;userId\u0026#34;: \u0026#34;user-test-01\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;quantity\u0026#34;: 2, \u0026#34;price\u0026#34;: 260000, \u0026#34;productId\u0026#34;: \u0026#34;p-002\u0026#34; }, { \u0026#34;quantity\u0026#34;: 4, \u0026#34;price\u0026#34;: 250000, \u0026#34;productId\u0026#34;: \u0026#34;p-001\u0026#34; } ] } ![connect ec2](/workshop01-AWS-FCJ-2025/images/4-2/08.png?width=50pc) Test /basket/checkout Sau khi nó phản hồi như thế này Checkout processing started -\u0026gt; nó đã gửi sự kiện bất đồng bộ Kiểm tra CloudWatch Vào AWS Console, nhập CloudWatch và click. Click Log group từ slider bên trái, click kiểm tra log của BasketFunction1 Kiểm tra log mới nhất và ta thấy Checkout event sent to EventBridge -\u0026gt; sự kiện đã được gửi đi Click kiểm tra tiếp log của OrderingFunction1 Ta thấy được log lambda thấy được SQS và lưu vào dynamoDB thành công. Kiểm tra bảng OrderingTable Ta thấy được OrderingTable đã được tạo thành công bằng cách kích hoạt Lambda function OrderingFunction1 từ SQS. "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/6-cognito/6.3-updatecodelambda/","title":"Cập nhật code Lambda để sử dụng token","tags":[],"description":"","content":"Mục tiêu Khi Cognito cho phép một yêu cầu đi qua, nó sẽ \u0026ldquo;đính kèm\u0026rdquo; thông tin của người dùng (như userId, email\u0026hellip;) vào request. Chúng ta sẽ cập nhật code Lambda để đọc userId từ thông tin an toàn này, thay vì đọc từ body (thứ có thể bị giả mạo). Thực hành Truy cập dịch vụ Lambda, cập nhật code BasketFunction1 và deploy import { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, PutCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { EventBridgeClient, PutEventsCommand } from \u0026#34;@aws-sdk/client-eventbridge\u0026#34;; const ddbClient = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(ddbClient); const ebClient = new EventBridgeClient({}); const basketTable = \u0026#34;BasketTable\u0026#34;; export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); const { httpMethod, path, body } = event; let responseBody; let statusCode = 200; // --- LOGIC MỚI: LẤY userId TỪ TOKEN --- // Khi dùng Cognito Authorizer, thông tin user sẽ nằm trong đây // \u0026#34;sub\u0026#34; (subject) chính là userId duy nhất của Cognito const userId = event.requestContext?.authorizer?.claims?.sub; if (!userId) { return { statusCode: 401, body: JSON.stringify({ message: \u0026#34;Unauthorized - No user ID found in token.\u0026#34; }) }; } // ---------------------------------------- try { if (httpMethod === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; path.includes(\u0026#34;/checkout\u0026#34;)) { console.log(`Processing checkout for user: ${userId}`); const basketData = JSON.parse(body || \u0026#39;{}\u0026#39;); const eventDetail = { ...basketData, userId: userId // Ghi đè userId bằng userId từ token }; const eventParams = { Entries: [ { Source: \u0026#34;com.ecommerce.basket\u0026#34;, DetailType: \u0026#34;CheckoutEvent\u0026#34;, Detail: JSON.stringify(eventDetail), EventBusName: \u0026#34;default\u0026#34; }, ], }; await ebClient.send(new PutEventsCommand(eventParams)); responseBody = { message: \u0026#34;Checkout processing started\u0026#34;, eventData: eventDetail }; } else if (httpMethod === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; path.includes(\u0026#34;/basket\u0026#34;)) { const basketData = JSON.parse(body || \u0026#39;{}\u0026#39;); const params = { TableName: basketTable, Item: { ...basketData, userId: userId // Ghi đè userId bằng userId từ token } }; await ddbDocClient.send(new PutCommand(params)); responseBody = { message: \u0026#34;Basket updated\u0026#34;, basket: params.Item }; } else { statusCode = 400; responseBody = { message: \u0026#34;Unsupported method or path\u0026#34; }; } } catch (err) { console.error(err); statusCode = 500; responseBody = { message: \u0026#34;Internal server error\u0026#34;, error: err.message }; } return { statusCode: statusCode, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(responseBody), }; }; Cập nhật code OrderingFunction1 và deploy import { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, PutCommand, ScanCommand, QueryCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { randomUUID } from \u0026#34;crypto\u0026#34;; const ddbClient = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(ddbClient); const orderTable = \u0026#34;OrderingTable\u0026#34;; const indexName = \u0026#34;UserOrdersIndex\u0026#34;; export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); if (event.Records) { console.log(\u0026#34;Processing SQS message...\u0026#34;); try { for (const record of event.Records) { const sqsBody = JSON.parse(record.body); const checkoutEventData = sqsBody.detail; console.log(\u0026#34;Checkout data from SQS:\u0026#34;, checkoutEventData); const orderId = randomUUID(); const orderParams = { TableName: orderTable, Item: { orderId: orderId, userId: checkoutEventData.userId, items: checkoutEventData.items, status: \u0026#34;PENDING\u0026#34;, createdAt: new Date().toISOString() } }; await ddbDocClient.send(new PutCommand(orderParams)); console.log(`Order ${orderId} saved successfully.`); } return { message: \u0026#34;SQS messages processed successfully.\u0026#34; }; } catch (err) { console.error(\u0026#34;Error processing SQS message:\u0026#34;, err); throw err; } } // ----- XỬ LÝ API GATEWAY ----- else if (event.httpMethod) { console.log(\u0026#34;Processing API Gateway request...\u0026#34;); const userIdFromToken = event.requestContext?.authorizer?.claims?.sub; if (!userIdFromToken) { return { statusCode: 401, body: JSON.stringify({ message: \u0026#34;Unauthorized - No user ID found in token.\u0026#34; }) }; } // ---------------------------------------- if (event.httpMethod === \u0026#34;GET\u0026#34;) { let responseBody; try { // --- LOGIC MỚI: Ưu tiên userId từ token --- // Chúng ta không cho phép user này xem đơn hàng của user khác console.log(`Querying orders for authenticated user: ${userIdFromToken} using GSI`); const params = { TableName: orderTable, IndexName: indexName, KeyConditionExpression: \u0026#34;userId = :uid\u0026#34;, ExpressionAttributeValues: { \u0026#34;:uid\u0026#34;: userIdFromToken // CHỈ dùng userId từ token } }; const { Items } = await ddbDocClient.send(new QueryCommand(params)); responseBody = Items; return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(responseBody) }; } catch (err) { console.error(err); return { statusCode: 500, body: JSON.stringify({ message: \u0026#34;Internal server error\u0026#34;, error: err.message }) }; } } } console.warn(\u0026#34;Unknown event type\u0026#34;); return { statusCode: 400, body: JSON.stringify({ message: \u0026#34;Unsupported event source\u0026#34; }) }; }; "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/3-processorderhandler/3.3-triggerlambdatosqs/","title":"Kết nối SQS với Lambda","tags":[],"description":"","content":"Mục tiêu Cấu hình hàm OrderingFunction1 của chúng ta để nó tự động được \u0026ldquo;kích hoạt\u0026rdquo; (trigger) mỗi khi có tin nhắn mới trong OrderingQueue1.\nThực hành Truy cập AWS Console, nhập EventBridge và truy cập vào dịch vụ Amazon EventBridge Từ danh sách các hàm lambda, click OrderingFunction1 và chọn Add trigger Trong giao diện add trigger\nSelect a source chọn: SQS SQS Queue chọn OrderingQueue1 Click Add Kiểm tra đã trigger thành công "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/2-preparationsteps/2.3-createlambda/","title":"Tạo Lambda Functions","tags":[],"description":"","content":"Trong bước này, chúng ta sẽ tạo các Lambda function cho microservices.\nTạo ProductFunction1 Truy cập AWS Console và điều hướng đến dịch vụ Lambda trong AWS Console. Từ slider bên trái chọn Functions và click Create function. Cấu hình function:\nChọn Author from scratch Function name: ProductFunction1 Runtime: Node.js 22.x Architecture: arm64 Execution role: Use an existing role → ProductLambdaRole1 Click Create function. Thay thế code mặc định bằng:\nimport { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, ScanCommand, GetCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; // Khởi tạo client DynamoDB const client = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(client); const tableName = \u0026#34;ProductTable\u0026#34;; // Tên bảng của bạn export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); let responseBody; let statusCode = 200; const httpMethod = event.httpMethod; const pathParams = event.pathParameters; try { if (httpMethod === \u0026#34;GET\u0026#34;) { if (pathParams \u0026amp;\u0026amp; pathParams.productId) { // Lấy 1 sản phẩm cụ thể: GET /products/{productId} const params = { TableName: tableName, Key: { productId: pathParams.productId, }, }; const { Item } = await ddbDocClient.send(new GetCommand(params)); responseBody = Item ? Item : { message: \u0026#34;Product not found.\u0026#34; }; if (!Item) statusCode = 404; } else { // Lấy tất cả sản phẩm: GET /products const params = { TableName: tableName, }; const { Items } = await ddbDocClient.send(new ScanCommand(params)); responseBody = Items; } } else { statusCode = 400; responseBody = { message: \u0026#34;Unsupported method\u0026#34; }; } } catch (err) { console.error(err); statusCode = 500; responseBody = { message: \u0026#34;Internal server error\u0026#34;, error: err.message }; } // Trả về kết quả cho API Gateway (định dạng Lambda Proxy) return { statusCode: statusCode, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(responseBody), }; }; Click Deploy. Tạo BasketFunction1 Tạo function khác tương tự như trên với:\nFunction name: BasketFunction1 Runtime: Node.js 22.x Architecture: arm64 Execution role: BasketLambdaRole1 Thay thế code bằng:\nimport { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, PutCommand, GetCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { EventBridgeClient, PutEventsCommand } from \u0026#34;@aws-sdk/client-eventbridge\u0026#34;; // Khởi tạo các client const ddbClient = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(ddbClient); const ebClient = new EventBridgeClient({}); // Client cho EventBridge const basketTable = \u0026#34;BasketTable\u0026#34;; export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); const { httpMethod, path, body } = event; let responseBody; let statusCode = 200; try { if (httpMethod === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; path.includes(\u0026#34;/checkout\u0026#34;)) { // ---- XỬ LÝ CHECKOUT VÀ GỬI EVENT ---- console.log(\u0026#34;Processing checkout...\u0026#34;); const checkoutData = JSON.parse(body || \u0026#39;{}\u0026#39;); // Validate sơ bộ if (!checkoutData.userId) { return { statusCode: 400, body: JSON.stringify({ message: \u0026#34;userId is required for checkout.\u0026#34; }) }; } // 1. Tạo sự kiện để gửi đi const eventParams = { Entries: [ { Source: \u0026#34;com.ecommerce.basket\u0026#34;, // Tên nguồn (phải nhớ để tạo Rule) DetailType: \u0026#34;CheckoutEvent\u0026#34;, // Tên sự kiện (phải nhớ để tạo Rule) Detail: JSON.stringify(checkoutData), // Nội dung sự kiện (toàn bộ giỏ hàng) EventBusName: \u0026#34;default\u0026#34; // Dùng event bus mặc định }, ], }; // 2. Gửi sự kiện đến EventBridge await ebClient.send(new PutEventsCommand(eventParams)); console.log(\u0026#34;Checkout event sent to EventBridge.\u0026#34;); responseBody = { message: \u0026#34;Checkout processing started\u0026#34;, eventData: checkoutData }; } else if (httpMethod === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; path.includes(\u0026#34;/basket\u0026#34;)) { // ---- XỬ LÝ CẬP NHẬT GIỎ HÀNG ---- const basketData = JSON.parse(body || \u0026#39;{}\u0026#39;); if (!basketData.userId) { return { statusCode: 400, body: JSON.stringify({ message: \u0026#34;userId is required.\u0026#34; }) }; } const params = { TableName: basketTable, Item: basketData // Lưu toàn bộ giỏ hàng }; await ddbDocClient.send(new PutCommand(params)); responseBody = { message: \u0026#34;Basket updated\u0026#34;, basket: basketData }; } else { statusCode = 400; responseBody = { message: \u0026#34;Unsupported method or path\u0026#34; }; } } catch (err) { console.error(err); statusCode = 500; responseBody = { message: \u0026#34;Internal server error\u0026#34;, error: err.message }; } return { statusCode: statusCode, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(responseBody), }; }; Click Deploy. Tạo OrderingFunction1 Tạo function khác với:\nFunction name: OrderingFunction1 Runtime: Node.js 22.x Architecture: arm64 Execution role: OrderingLambdaRole Thay thế code bằng:\nimport { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; import { DynamoDBDocumentClient, PutCommand, ScanCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { randomUUID } from \u0026#34;crypto\u0026#34;; const ddbClient = new DynamoDBClient({}); const ddbDocClient = DynamoDBDocumentClient.from(ddbClient); const orderTable = \u0026#34;OrderingTable\u0026#34;; export const handler = async (event) =\u0026gt; { console.log(\u0026#34;Event received:\u0026#34;, JSON.stringify(event)); // ----- XỬ LÝ KHI ĐƯỢC KÍCH HOẠT BỞI SQS ----- // event.Records là một mảng, SQS có thể gửi nhiều tin nhắn 1 lúc if (event.Records) { console.log(\u0026#34;Processing SQS message...\u0026#34;); try { for (const record of event.Records) { const sqsBody = JSON.parse(record.body); // Sự kiện từ EventBridge sẽ nằm trong trường \u0026#39;detail\u0026#39; của SQS body const checkoutEventData = sqsBody.detail; console.log(\u0026#34;Checkout data from SQS:\u0026#34;, checkoutEventData); // 1. Tạo một orderId mới const orderId = randomUUID(); // 2. Tạo đối tượng đơn hàng để lưu const orderParams = { TableName: orderTable, Item: { orderId: orderId, userId: checkoutEventData.userId, items: checkoutEventData.items, status: \u0026#34;PENDING\u0026#34;, // Trạng thái ban đầu createdAt: new Date().toISOString() } }; // 3. Lưu đơn hàng vào DynamoDB await ddbDocClient.send(new PutCommand(orderParams)); console.log(`Order ${orderId} saved successfully.`); } // Hàm Lambda được SQS kích hoạt không cần trả về gì return { message: \u0026#34;SQS messages processed successfully.\u0026#34; }; } catch (err) { console.error(\u0026#34;Error processing SQS message:\u0026#34;, err); // Quan trọng: Nếu ném lỗi, SQS sẽ thử gửi lại tin nhắn sau throw err; } } // ----- XỬ LÝ KHI ĐƯỢC KÍCH HOẠT BỞI API GATEWAY ----- else if (event.httpMethod) { console.log(\u0026#34;Processing API Gateway request...\u0026#34;); // Logic cho API GET /orders (lấy tất cả đơn hàng) if (event.httpMethod === \u0026#34;GET\u0026#34;) { try { const params = { TableName: orderTable, }; const { Items } = await ddbDocClient.send(new ScanCommand(params)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify(Items) }; } catch (err) { console.error(err); return { statusCode: 500, body: JSON.stringify({ message: \u0026#34;Internal server error\u0026#34; }) }; } } } // Trường hợp không xác định console.warn(\u0026#34;Unknown event type\u0026#34;); return { statusCode: 400, body: JSON.stringify({ message: \u0026#34;Unsupported event source\u0026#34; }) }; }; Click Deploy. Tất cả Lambda functions đã được tạo thành công!\n"},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/3-processorderhandler/","title":"Tạo luồng xử lý bất đồng bộ","tags":[],"description":"","content":"Luồng xử lý bất đồng bộ là gì? Luồng xử lý mà người gửi (producer) không cần chờ người nhận (consumer) xử lý xong ngay lập tức, mà tiếp tục hoạt động, còn công việc được xử lý ở nền (background) thông qua cơ chế trung gian (queue, event bus, callback…).\nNội dung Tạo SQS Tạo EventBridge Kích hoạt Lambda với SQS "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/6-cognito/6.4-createusertoken/","title":"Tạo user và token để xác thực để sử dụng API","tags":[],"description":"","content":"Mục tiêu Để có thể sử dụng được api thì chúng ta cần đưa một cái chứng thực (token) để API Gateway biết bạn là ai và cho phép sử dụng nó. Thực hành Truy cập dịch vụ Cognito, click vào User Pool của bạn\nClick vào tab Users Nhập email của bạn Nhập mật khẩu Kết quả Để có thể đăng nhập bằng user, password chúng ta cần bật như ảnh dưới Lấy id-token từ cli để sử dụng api\nNhập lệnh sau aws cognito-idp initiate-auth --auth-flow USER_PASSWORD_AUTH \\ --client-id [YOUR_CLIENT_ID] \\ --auth-parameters USERNAME=[YOUR_USER],PASSWORD=[YOUR_PASS] \\ --region ap-southeast-1 - Tiếp tục nhập lệnh để đổi mật khẩu lần đầu bash\raws cognito-idp respond-to-auth-challenge --challenge-name NEW_PASSWORD_REQUIRED --client-id 3i5aerjeech7l3kir5j8gkqs3t --challenge-responses USERNAME=hieuthptchuyenbl@gmail.com,NEW_PASSWORD=123456Aa@ --session \u0026quot;[DÁN_CHUỖI_SESSION]\u0026quot; --region ap-southeast-1\rCopy Id-token đó rồi dán vào Postman như ảnh dưới Cột Key nhập Authorization\nCột Value nhập Id-token của bạn\nClick send và api đã phản hồi Tương tự với api khác "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/4-apigateway/","title":"Triển khai API Gateway","tags":[],"description":"","content":"Triển khai API Gateway Trong section này, chúng ta sẽ tạo API Gateway để có thể kích hoạt hàm lambda chạy luồng xử lý bất đồng bộ\nNội dung Tạo Rest API Test api "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/5-stepoptimal/","title":"Những bước nâng cao tối ưu","tags":[],"description":"","content":"Giới thiệu Ở section này, chúng ta sẽ tạo Dead Letter Queue - DLQ để xử lý tin nhắn chết và index userId cho OrderingTable để tăng tốc độ truy vấn.\nNội dung: Tạo SQS Dead xử lý tin nhắn lỗi Tạo Index để tăng tốc độ truy vấn "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/6-cognito/","title":"Triển khai Cognito để bảo vệ API","tags":[],"description":"","content":"Giới thiệu Amazon Cognito là dịch vụ của AWS dùng để xác thực (authentication) và quản lý người dùng (user management) cho ứng dụng web hoặc mobile.\nCognito giúp bạn dễ dàng: - Tạo và lưu trữ tài khoản người dùng trong User Pool. - Hỗ trợ đăng nhập bằng email, số điện thoại, hoặc tài khoản mạng xã hội (Google, Facebook\u0026hellip;). - Cung cấp Hosted UI để người dùng đăng ký, đăng nhập mà không cần tự xây dựng trang login. - Tích hợp dễ dàng với API Gateway và AWS Lambda để bảo vệ API bằng JWT token (ID token, Access token). Nhờ đó, bạn có thể nhanh chóng thêm tính năng đăng ký, đăng nhập, xác thực bảo mật cho hệ thống microservice mà không cần quản lý server hay cơ sở dữ liệu người dùng thủ công.\nNội dung: Tạo user pool Cấu hình API Gateway Cập nhật code lambda Tạo User Token "},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/7-cleanupresource/","title":"Dọn dẹp tài nguyên","tags":[],"description":"","content":"Dọn dẹp tài nguyên Chúng ta sẽ tiến hành xóa các tài nguyên theo thứ tự sau:\n"},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://Hieu192.github.io/workshop1-10-2025/vi/tags/","title":"Tags","tags":[],"description":"","content":""}]